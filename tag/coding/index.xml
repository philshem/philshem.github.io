<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>coding | small DATA</title><link>https://smalldata.dev/tag/coding/</link><atom:link href="https://smalldata.dev/tag/coding/index.xml" rel="self" type="application/rss+xml"/><description>coding</description><generator>Source Themes Academic (https://sourcethemes.com/academic/)</generator><language>en-us</language><lastBuildDate>Mon, 31 Aug 2020 00:00:00 +0000</lastBuildDate><image><url>https://smalldata.dev/images/icon_hu15c4e386fa9af0b23c15ab588f3cb903_1591_512x512_fill_lanczos_center_2.png</url><title>coding</title><link>https://smalldata.dev/tag/coding/</link></image><item><title>Generating folders with smart dates in Python + Pandas</title><link>https://smalldata.dev/posts/python-date-folders/</link><pubDate>Mon, 31 Aug 2020 00:00:00 +0000</pubDate><guid>https://smalldata.dev/posts/python-date-folders/</guid><description>&lt;blockquote>
&lt;p>&lt;em>Not everything your mother told you is true.&lt;/em>&lt;/p>
&lt;/blockquote>
&lt;p>&lt;small>&amp;ndash;my CompSci 101 professor, when a student &lt;em>insisted&lt;/em> that, without exception, every 4th year was a leap year&lt;/small>&lt;/p>
&lt;hr>
&lt;h3 id="the-idea">the idea&lt;/h3>
&lt;p>For a hobby project, I needed to generate thousands folders and sub-folders and sub-sub-folders based on calendar dates within a range.&lt;/p>
&lt;p>This means, I wanted to have a main folder, called something like &lt;code>tmp_dates/&lt;/code>. In that folder, I wanted to have sub-folders for each year within a range: &lt;code>tmp_dates/2020/&lt;/code>. And sub-folders for months: &lt;code>tmp_dates/2020/06/&lt;/code>. And sub-folders for days: &lt;code>tmp_dates/2020/06/30&lt;/code>.&lt;/p>
&lt;h3 id="smart-calendar-dates-and-leap-years">smart calendar dates and leap years&lt;/h3>
&lt;p>Using Python&amp;rsquo;s standard &lt;code>datetime&lt;/code> library, I can easily generate date ranges with &lt;code>timedelta()&lt;/code>. This is necessary for generating &amp;ldquo;smart&amp;rdquo;-dates that take into account varying days per month, as well as those pesky leap years. It turns out that the
&lt;a href="https://en.wikipedia.org/wiki/Leap_year#Algorithm" target="_blank" rel="noopener">rules for leap years&lt;/a> are &lt;strong>not&lt;/strong> as simple as years that are multiples of 4. &lt;small>Sadly, for those of us born in the late 20th Century, we won&amp;rsquo;t be alive to see a year divisible by 4 that is &lt;em>not&lt;/em> a leap year. The next one of those is year &lt;code>2100&lt;/code>. The year &lt;code>2000&lt;/code> was a leap year despite being divisible by 100 because it was also divisible by 400.&lt;/small>&lt;/p>
&lt;p>Wrapping the date-range functionality with Pandas makes the code extremely efficient. Here&amp;rsquo;s an adapted
&lt;a href="https://stackoverflow.com/a/59882807/2327328" target="_blank" rel="noopener">StackOverflow snippet&lt;/a> which does the heavy lifting.&lt;/p>
&lt;pre>&lt;code class="language-python">import pandas as pd
from datetime import date, timedelta
sdate = date(2000,1,1) # start date
edate = date.today() # end date
df = pd.date_range(sdate,edate-timedelta(days=1),freq='d')
&lt;/code>&lt;/pre>
&lt;h3 id="generating-sub-folders-based-on-a-date-range">generating (sub-)folders based on a date range&lt;/h3>
&lt;p>In addition to generating the date-folders, I want my code to create folders but not overwrite files if a folder exists. For this I used
&lt;a href="https://stackoverflow.com/a/273227/2327328" target="_blank" rel="noopener">this snippet&lt;/a> that uses the wonderful new Python3 library
&lt;a href="https://docs.python.org/3/library/pathlib.html" target="_blank" rel="noopener">&lt;code>pathlib.Path()&lt;/code>&lt;/a> to create a folder called &lt;code>tmp_dates/&lt;/code> in the current working directory. If that folder already exists, it will otherwise ignored.&lt;/p>
&lt;pre>&lt;code class="language-python">from pathlib import Path
Path('tmp_dates/').mkdir(parents=True, exist_ok=True)
&lt;/code>&lt;/pre>
&lt;h3 id="adding-an-empty-file-to-each-folder">adding an empty file to each folder&lt;/h3>
&lt;p>Git can&amp;rsquo;t handle an empty directory. To include empty directories, on Github at least, there is an
&lt;a href="https://stackoverflow.com/a/7229996/2327328" target="_blank" rel="noopener">undocumented feature&lt;/a> where an empty folder that has the empty file &lt;code>.gitkeep&lt;/code> will be included in the version control. The &lt;code>pathlib.Path()&lt;/code> library can even create an empty file, using the
&lt;a href="https://docs.python.org/3/library/pathlib.html#pathlib.Path.touch" target="_blank" rel="noopener">&lt;code>.touch()&lt;/code>&lt;/a> function, which copies its functionality from the
&lt;a href="https://en.wikipedia.org/wiki/Touch_%28command%29#Overview" target="_blank" rel="noopener">Unix touch command&lt;/a>.&lt;/p>
&lt;pre>&lt;code class="language-python">from pathlib import Path
Path('tmp_dates/').mkdir(parents=True, exist_ok=True)
Path('tmp_dates/'+os.sep+'.gitkeep').touch()
&lt;/code>&lt;/pre>
&lt;h3 id="putting-it-all-together">putting it all together&lt;/h3>
&lt;p>All that&amp;rsquo;s left is to combine all the pieces into one Python3 script that safely generates sub-folders for individual calendar dates in a date range.&lt;/p>
&lt;pre>&lt;code class="language-python">from datetime import date, timedelta
import pandas as pd
from pathlib import Path #requires Python&amp;gt;=3.5
import os
# safe generate folders for all dates within a range
def create_folder(p):
Path(p).mkdir(parents=True, exist_ok=True)
Path(p+os.sep+'.gitkeep').touch()
# where to start to put the many folders
subpath = 'tmp_dates'
# start and end date
sdate = date(2000,1,1) # start date
edate = date.today() # end date
# use pandas for the heavy lifting of building the calendar-aware date range
df = pd.date_range(sdate,edate-timedelta(days=1),freq='d')
# loop over all values and create a folder for each possible date
for d in df:
#print(d.year, d.month, d.day)
path = subpath + os.sep + str(d.year).zfill(4) + os.sep + str(d.month).zfill(2) + os.sep + str(d.day).zfill(2)
create_folder(path)
#break # debugging
&lt;/code>&lt;/pre></description></item><item><title>Fun with Favicons</title><link>https://smalldata.dev/posts/favicon-mosaic/</link><pubDate>Wed, 17 Apr 2019 00:00:00 +0000</pubDate><guid>https://smalldata.dev/posts/favicon-mosaic/</guid><description>&lt;p>A recent
&lt;a href="https://opendata.stackexchange.com/q/14007/1511" target="_blank" rel="noopener">question&lt;/a> on the Open Data Stack Exchange site got me thinking about how to download favicons from a bulk list of websites.&lt;/p>
&lt;h3 id="idea-1-try-each-domain">Idea 1: try each domain&lt;/h3>
&lt;p>Something like &lt;code>http://example.com/favicon.ico&lt;/code>. But using a &lt;code>favicon.ico&lt;/code> in the webroot folder is just a common implementation. Each website can host their favicon with another path, and another file format.&lt;/p>
&lt;p>Let&amp;rsquo;s try something else&amp;hellip;&lt;/p>
&lt;h3 id="idea-2-parse-html-for-favicon-urls">Idea 2: parse html for favicon urls&lt;/h3>
&lt;p>If the website doesn&amp;rsquo;t use &lt;code>favicon.ico&lt;/code> in the webroot folder, the page html will contain a path to the favicon, with the following format:&lt;/p>
&lt;pre>&lt;code>&amp;lt;link rel=icon href=https://smalldata.dev/favicon.png&amp;gt;
&lt;/code>&lt;/pre>
&lt;p>There is python package aptly named
&lt;a href="https://github.com/scottwernervt/favicon" target="_blank" rel="noopener">favicon&lt;/a> that will parse the html and return the urls to all favicons, with different formats and resolutions. I&amp;rsquo;m pasting their demo code here:&lt;/p>
&lt;pre>&lt;code class="language-python">&amp;gt;&amp;gt;&amp;gt; import favicon
&amp;gt;&amp;gt;&amp;gt; icons = favicon.get('https://www.python.org/')
Icon(url='https://www.python.org/static/apple-touch-icon-144x144-precomposed.png', width=144, height=144, format='png')
Icon(url='https://www.python.org/static/apple-touch-icon-114x114-precomposed.png', width=114, height=114, format='png')
Icon(url='https://www.python.org/static/apple-touch-icon-72x72-precomposed.png', width=72, height=72, format='png')
Icon(url='https://www.python.org/static/apple-touch-icon-precomposed.png', width=0, height=0, format='png')
Icon(url='https://www.python.org/static/favicon.ico', width=0, height=0, format='ico')
&lt;/code>&lt;/pre>
&lt;p>Getting better&amp;hellip; But if I download bulk favicons, I&amp;rsquo;d like to avoid normalizing their file format and resolutions.&lt;/p>
&lt;h3 id="idea-3-get-favicons-directly-from-googles-cache">Idea 3: get favicons directly from google&amp;rsquo;s cache&lt;/h3>
&lt;p>Google keeps the favicon cached for many sites (even my little website with basically zero traffic).&lt;/p>
&lt;pre>&lt;code>https://www.google.com/s2/favicons?domain=smalldata.dev
&lt;/code>&lt;/pre>
&lt;p>And the favicons are all normalized: 16x16 pixels and png format. Perfect.&lt;/p>
&lt;h2 id="now-for-some-fun">Now for some fun&lt;/h2>
&lt;p>A
&lt;a href="https://moz.com/top500" target="_blank" rel="noopener">top500 website list&lt;/a> has a
&lt;a href="https://moz.com/top500/domains/csv" target="_blank" rel="noopener">csv export&lt;/a> and wrote a Python script to download each of these 500 favicons from Google&amp;rsquo;s cache and save to local folder &lt;code>images/&lt;/code>.&lt;/p>
&lt;pre>&lt;code>import requests
import pandas as pd
import os
from io import StringIO
def request_function(domain):
domain = domain.replace('/','')
url = 'https://www.google.com/s2/favicons?domain=' + domain
fav = requests.get(url).content
with open('images'+os.sep+domain+'.png', 'wb') as handler:
handler.write(fav)
return
# top 500 websites from mozilla https://moz.com/top500
url = &amp;quot;https://moz.com:443/top500/domains/csv&amp;quot;
headers = {&amp;quot;User-Agent&amp;quot;: &amp;quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10.14; rv:66.0) Gecko/20100101 Firefox/66.0&amp;quot;}
req = requests.get(url, headers=headers)
data = StringIO(req.text)
df = pd.read_csv(data)
df.URL.apply(request_function)
&lt;/code>&lt;/pre>
&lt;h3 id="favicon-art">Favicon art&lt;/h3>
&lt;p>What to do with 500 favicons. For fun, I made a mosaic from the collection, and I first needed a original piece of art that would be recongnizable when heavily pixelated. Van Gogh&amp;rsquo;s
&lt;a href="https://en.wikipedia.org/wiki/The_Starry_Night" target="_blank" rel="noopener">Starry night&lt;/a> stood out.&lt;/p>
&lt;p>Here&amp;rsquo;s the original:&lt;/p>
&lt;p>&lt;img src="https://smalldata.dev/images/1137px-Van_Gogh_-_Starry_Night_-_Google_Art_Project.jpg" alt="Starry Night">&lt;/p>
&lt;p>&lt;em>Source&lt;/em>:
&lt;a href="https://en.wikipedia.org/wiki/The_Starry_Night#/media/File:Van_Gogh_-_Starry_Night_-_Google_Art_Project.jpg" target="_blank" rel="noopener">Wikipedia&lt;/a>&lt;/p>
&lt;p>Then I used a handy Python script called
&lt;a href="https://github.com/codebox/mosaic" target="_blank" rel="noopener">mosaic.py&lt;/a>. No coding necessary.&lt;/p>
&lt;pre>&lt;code>git clone https://github.com/codebox/mosaic.git
python mosaic/mosaic.py source.jpg images/
&lt;/code>&lt;/pre>
&lt;p>And what pops out is a &lt;em>Starry Night of Favicons&lt;/em>.&lt;/p>
&lt;p>&lt;img src="https://smalldata.dev/images/mosaic.jpeg" alt="Favicon Starry Night">&lt;/p>
&lt;hr>
&lt;p>(full resolution download:
&lt;a href="https://smalldata.dev/images/mosaic_full.jpeg">22 MB&lt;/a>)&lt;/p>
&lt;p>(python
&lt;a href="https://gist.github.com/philshem/e59388197fd9ddb7dcdb8098f9f0aaf2" target="_blank" rel="noopener">source code&lt;/a>)&lt;/p>
&lt;p>(top500 favicons:
&lt;a href="https://smalldata.dev/images/top500_favicons.zip">zip&lt;/a>)&lt;/p></description></item></channel></rss>